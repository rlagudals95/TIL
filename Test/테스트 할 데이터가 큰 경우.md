# 테스트 할 데이터가 큰 경우

종종 테스트를 작성하다 보면 테스트의 데이터가 너무 커서  
보는 이로 하여금 어떤 기능을 함수, 테스트인지 가독성이 너무 떨어지는 경우가 있습니다.

테스트의 중요한 목적중 하나는 해당 테스트의 목적과 기능을 작성자가 아닌 제 3자가 보았을때도
쉽게 파악할 수 있는게 중요하다고 생각하는데요,

큰 데이터를 테스트하는 경우에 어떤 식으로 가독성이 좋은 코드를 구성할 수 있는지 살펴 봅시다.


## 데이터가 큰 테스트  

아래와 같은 큰 데이터 타입의 배열을 매개변수로 받아 새로운 배열을 리턴하는 함수의 테스트를 작성한다고 가정해봅시다.

데이터를 보면 데이터의 속성도 너무 많을 뿐더러,
속성 하나하나가 원시 타입이 아닌 것도 많아 데이터의 깊이를 알 수 없는 속성도 많은데요,

해당 데이터 배열을 mock 데이터로 static하개 선언후 테스트를 작성한다면 아마 테스트 작성자 본인도 
다시 봤을 때 파악하기 어려운 테스트가 될 것 입니다...!

```
export interface OptionVariant {
  /** 옵션 조합 (ID 목록) */
  optionCombination: OptionCombination[];
  /** 판매마켓 */
  sellingMarket: OptionVariantSellingMarketEnum;
  /** 대표옵션여부 */
  isRepresentative: boolean;
  /** 판매마켓 등록여부 */
  isActive: boolean;
  /** 최종원가 */
  originalPrice: number;
  /** 최종원가 구성요소 */
  originalPriceAttribute: OriginalPriceAttribute;
  /** 판매가 */
  finalPrice: number;
  /** 마진율 */
  profitMargin: ProfitMargin;
  /** 뱃지 */
  badge: OptionVariantBadgeEnum;
  /**
   * 재고수량
   * @example 20
   */
  stock: number;
  /** 크기 */
  size?: Dimensions;
  /** 무게 */
  weight?: Weight;
}

```


## 테스트 작성해보기

위의 데이터 타입의 배열 형태인 optionVariants (OptionVariant[]) 형태의 매개 변수를 받아,
optionVariants들 중  sellingMarket과 combination이 완전히 같은 
variants 중복제거해 새로운 배열을 return 하는 함수를 만들었습니다.


이름은 `removeCombinationDuplicateOptionVariants`으로 optionVariants를 매겨변수로 받아 optionVariants를 리턴하는 함수입니다.


이 테스트의 목적은 아래와 같습니다.

### optionVariants 중 optionCombination과 sellingMarket이 완전히 같은 배열요소는 중복을 제거한다.

위의 목적을 토대로 보아, 이 테스트의 핵심 키워드는 
OptionVariant의 데이터 속성 중 optionCombination과 sellingMarket이 될 것 입니다.






















